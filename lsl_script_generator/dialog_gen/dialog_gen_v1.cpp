// Program to automatically generate LSL scripts for player to interact with
// dialog and text boxes from the dialog description written in the DOT language
//
// Created by Andrew M. Yuan, send you comments to andrewyuan6@gmail.com
// all rights reserved, 2018.
//
// to run the program: 
//   > g++ dialog_gen_v1.cpp
//   > ./a.out inputfilename outputfilename
//
//  inputfile is a text file, describing dialog in the DOT language
//  example input files: g1.txt, g2.txt, phisics_lab_corrected.txt
//
//  output is a LSL script file.
//  example usage: ./a.out phisics_lab_corrected.txt phisics_lab_corrected.lsl
//
//  developer's guide for this program is at dialog_script_doc.docx
//

#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <string>
#include <string.h>
#include <algorithm>

// MAX_NODE: the maximum size of the dialog graph
// MAX_FANOUT: the maximum number of options in the dialog

#define MAX_NODE 1000
#define MAX_FANOUT 10

using namespace std;

// internal graph structure with labels

string nodeName[MAX_NODE];
string nodeLabel[MAX_NODE];

int edge[MAX_NODE][MAX_FANOUT];
string edgeLabel[MAX_NODE][MAX_FANOUT];

string graphName;
int numOfNodes;

ofstream outfile;

// routine for reading the DOT file
// this routing convert the DOT text file into the internal graph
// the LSL script is generated from the internal graph

void readGraph(string name)
{
  ifstream infile(name.c_str());
  string line;
  char *str;

  char buf[10000];
  char sName[1000];
  char dName[1000];
  char label[5000];
  char pName[1000];
  char tmp[1000];
  int sindex;
  int dindex, i, j;


  numOfNodes = 0;
  for (i=0; i<MAX_NODE; i++)
    for (j=0; j<MAX_FANOUT; j++) edge[i][j] = -1;
  
  getline(infile, line);
  strcpy(buf, line.c_str());
  str = buf;
  sscanf(str, "%s %s", tmp, pName);
  graphName = pName;  

  while (std::getline(infile, line)) {
    strcpy(buf, line.c_str());
    str = buf;

    i = 0;
    while ((str[i] == ' ') || (str[i] == '\t') || (str[i] == '{') ||
	   (str[i] == '}') || (str[i] == ';') || 
           (str[i] == '\r') || (str[i] == '\n')) i++;
    if (str[i] == '\0') continue;
    
    if (strstr(str, "->") != NULL) {
      /* find an edge */
      sscanf(str, "%s %s %s", sName, tmp, dName);
      char *ss = strstr(str, "\"");
      ss++;
      char *dd = label;
      while ((*ss!= '"') && (*ss !='\0')) *dd++ = *ss++;
      *dd = '\0';
      
      for (sindex=0; sindex<numOfNodes; sindex++) 
        if (nodeName[sindex] == sName) break;

      for (dindex=0; dindex<numOfNodes; dindex++) 
        if (nodeName[dindex] == dName) break;
      if ((sindex == numOfNodes) && (dindex == numOfNodes)) {
	cout << "index out of bound, buf = " << buf << "\n";
	cout << sName << " -> " << dName << "\n";
	exit(0);
      }
      for (i = 0; i<MAX_FANOUT; i++) if (edge[sindex][i] == -1) break;
	
      if (i==MAX_FANOUT) {
	cout << "node " << sindex << " : " << sName <<
	  " has too many fanout\n";
	exit(0);
      }

      edge[sindex][i] = dindex;
      edgeLabel[sindex][i] = label;
      /*
      cout << "s = " << nodeName[sindex] << ", " << sindex
	   << "d = " << nodeName[dindex] << ", " << dindex
           << " i = " << i << ", edge[s][i] = " << edge[sindex][i] << "\n";	*/
    } else { /* line for node */
      sscanf(str, "%s", sName);
      char *ss = strstr(str, "\"");
      ss++;
      char *dd = label;
      while ((*ss!= '"') && (*ss !='\0')) *dd++ = *ss++;
      *dd = '\0';
     
      for (sindex=0; sindex<numOfNodes; sindex++) 
        if (nodeName[sindex] == sName) break;
      if ((sindex != numOfNodes)) {
	cout << "Node " << sName << " redefined.\n";
	exit(0);
      }
      nodeName[sindex] = sName;
      nodeLabel[sindex] = label;
      numOfNodes ++;
    }
  }
}

// routine to print the graph
// 
void printGraph()
{
  int i, j;

  cout << "digraph " << graphName << " {\n"; fflush(0);
  for (i=0; i<numOfNodes; i++) {
    cout <<   "  " << nodeName[i] << " [label=\"" <<
      nodeLabel[i] <<"\"];\n";
  }

  cout << "\n";
  
  for (i=0; i<numOfNodes; i++) {
    for (j=0; j<MAX_FANOUT; j++) {
      if (edge[i][j] != -1) {
	cout << "  " << nodeName[i] << " -> " << nodeName[edge[i][j]]
	     << " [label=\"" << edgeLabel[i][j] << "\"];\n";
      }
    }
  }
  cout << "}\n";
}

// this routine generate the headers for the script
void gen_header()
{
  outfile << "// This script is automatically generated by Andrew Yuan LSL automatic generation tool kit. \n";
  outfile << "// This tool reads from a dialog flow graph described in the DOT language \n";
  outfile << "// and outputs the script.\n\n";
  outfile << "// Some variable that you might want to modify: dialog_box_interact_interval,\n";
  outfile << "//    state_control_channel, and local_dialog_channle\n\n";
}

// generate variables that are used in all scripts
// the useful variables are decided from Ray's hand-coded script.
void gen_fixed_variables()
{
  outfile << "key dialog_target = NULL_KEY; // key of the person to talk to\n" ;
  outfile << "string state_name;            // name of the current state \n";
  outfile << "integer timer_count;          // counter of timer\n";
  outfile << "integer dialog_box_interact_interval = 20; // time in second when dialog is expected\n";

  outfile << "integer state_control_channel = 10001; // state_control channel\n";
  outfile << "integer local_dialog_channel = 11001; // channel used by dialog box\n";
}

// generate messags and buttons variables used in the dialog and texboxes in 
// the conversion
// the format is the same as the hand-coded script from Ray
void gen_msg_button()
{
  int i, j, k;
  char buf[10000];
  char buf1[10000];

  outfile <<"\n";
  for (i=0; i<numOfNodes; i++) {
    // the line for msg for each state
    sprintf(buf, "string %s_msg = \"%s\";", nodeName[i].c_str(), nodeLabel[i].c_str());
    outfile << buf << "\n";
    // now the button line
    for (j=0; (j<MAX_FANOUT) && (edge[i][j] != -1); j++);
    if ((j == 1) && (strcmp(edgeLabel[i][0].c_str(), "Submit") == 0)) {
      sprintf(buf, "list %s_button = [];", nodeName[i].c_str());
      outfile << buf << "\n\n";
    } else {
      sprintf(buf, "list %s_button = [", nodeName[i].c_str());
      for (k=0; k<j-1; k++) {
	strcat(buf, "\"");
	strcat(buf, edgeLabel[i][k].c_str());
	strcat(buf, "\", ");
      }
      strcat(buf, "\"");
      strcat(buf, edgeLabel[i][k].c_str());
      strcat(buf, "\"];");
      outfile << buf << "\n\n";
    }
  }
}

// these routines are copied from Ray's LSL script
void gen_utility_routine()
{
  outfile << "reset_script() {\n";
  outfile << "  dialog_target = NULL_KEY;\n";
  outfile << "  state_name = \"default\";\n";
  outfile << "}\n\n";

  outfile << "register_common_channel()\n";
  outfile << "{\n";
  outfile << "  llListen(state_control_channel, \"\", NULL_KEY, \"\");\n";
  outfile << "  llListen(local_dialog_channel, \"\", NULL_KEY, \"\");\n";
  outfile << "}\n\n";

  outfile << "register_common_channel_timer(integer t)\n";
  outfile << "{\n";
  outfile << "  llListen(state_control_channel, \"\", NULL_KEY, \"\");\n";
  outfile << "  llListen(local_dialog_channel, \"\", NULL_KEY, \"\");\n";
  outfile << "  llSetTimerEvent(t);\n";
  outfile << "}\n\n";

  outfile << "common_state_entry(string n, string s, list l, integer t)\n";
  outfile << "{\n";
  outfile << "  state_name = n; timer_count = 0;\n";
  outfile << "  if (l == [])\n";
  outfile << "    llTextBox(dialog_target, s, local_dialog_channel);\n";
  outfile << "  else llDialog(dialog_target, s, l, local_dialog_channel);\n";
  outfile << "   register_common_channel_timer(t);\n";
  outfile << "}\n\n";

  outfile << "dialog_with_timer(string msg, list button, integer t)\n";
  outfile << "{\n";
  outfile << "  llSetTimerEvent(t);\n";
  outfile << "  if (button == [])\n";
  outfile << "    llTextBox(dialog_target, msg, local_dialog_channel);\n";
  outfile << "  else llDialog(dialog_target, msg, button, local_dialog_channel);\n";
  outfile << "}\n\n";

  outfile << "dialog_with_timer_count(string msg, list button, integer t)\n";
  outfile << "{\n";
  outfile << "  timer_count ++;\n";
  outfile << "  if (timer_count >= 3) {llSetTimerEvent(0); llSay(0, \"timeout too many times, back to initial (idle) state\"); state default;}\n";
  outfile << "  llSetTimerEvent(t);\n";
  outfile << "  if (button == [])\n";
  outfile << "    llTextBox(dialog_target, msg, local_dialog_channel);\n";
  outfile << "  else llDialog(dialog_target, msg, button, local_dialog_channel);\n";
  outfile << "}\n\n";
}

// the control routine format is from Ray's LSL script
// '-start' and '-reset' are hard coded
// '-gotostate:statename' to reach state is then generated from each node
// in the graph
void gen_state_control_routine()
{
  int i, beg;
  char buf[10000];

  for (beg=0; beg<numOfNodes; beg++)
    if (strcmp(nodeName[beg].c_str(), "default") == 0) break;
  if (beg == numOfNodes) {
    cout << "You must have a default node in the graph.\n";
    exit(0);
  }
  beg = edge[beg][0];
  
  outfile << "process_state_control_msg(integer c, string n, key ID, string msg) {\n";
  outfile << "  if (c == state_control_channel) {\n";
  outfile << "    dialog_target = ID;\n";
  outfile << "    if (msg == \"-start\") {\n";
  sprintf(buf, "      llSetTimerEvent(0); state %s;\n", nodeName[beg].c_str());
  outfile << buf;
  outfile << "    } else if ((msg == \"-reset\") || (msg == \"-restart\")) {\n";
  outfile << "      reset_script();\n";
  outfile << "      llSetTimerEvent(0);\n";
  outfile << "      state default;\n";

  for(i=0; i<numOfNodes; i++) {
    sprintf(buf, "    } else if (msg == \"-gotostate:%s\") {\n", nodeName[i].c_str());
    outfile << buf;
    outfile << "      llSetTimerEvent(0);\n";
    sprintf(buf, "      state %s;\n", nodeName[i].c_str());
    outfile << buf;
  }

  outfile << "    } else {\n";
  sprintf(buf, "      llSay(0, \"unknown command \"+ msg + \", ignored\");\n    }\n  }\n}\n\n");
  outfile << buf;
}

// this routine generates all states, each dialog box corresponds to a 
// node. All state besides the default has the same structure.
// the difference among the states is that each state operates at 
// a set of different variables. 
void gen_state()
{
  int i, j;
  char buf[10000];

  for (i=0; i<numOfNodes; i++) {
    if (strcmp(nodeName[i].c_str(), "default") == 0) { // deal with default
      outfile << "default {\n\n";
      outfile << "  state_entry() {register_common_channel_timer(0);}\n\n";
      outfile << "  touch_start(integer num_detected) {\n";
      outfile << "    dialog_target = llDetectedKey(0);\n";
      sprintf(buf, "    state %s;\n", nodeName[edge[i][0]].c_str());
      outfile << buf;
      outfile << "  }\n\n";
      outfile << "  listen(integer c, string n, key ID, string msg) {\n";
      outfile << "    process_state_control_msg(c, n, ID, msg);\n";
      outfile << "  }\n}\n\n";
    } else {
      sprintf(buf, "state %s {\n\n", nodeName[i].c_str());
      outfile << buf;
      sprintf(buf, "  state_entry() {common_state_entry(\"%s\", %s_msg, %s_button, dialog_box_interact_interval);}\n\n", nodeName[i].c_str(), nodeName[i].c_str(), nodeName[i].c_str()); 
      outfile << buf;
      sprintf(buf, "  touch_start(integer num_detected) {dialog_with_timer(%s_msg, %s_button, dialog_box_interact_interval);}\n\n", nodeName[i].c_str(), nodeName[i].c_str()); 
      outfile << buf;
      sprintf(buf, "  timer() {dialog_with_timer_count(%s_msg, %s_button, dialog_box_interact_interval);}\n\n", nodeName[i].c_str(), nodeName[i].c_str()); 
      outfile << buf;
      
      outfile << "  listen(integer c, string n, key ID, string msg) {\n";
      outfile << "    llSetTimerEvent(dialog_box_interact_interval);\n";
      outfile << "    if (c == local_dialog_channel) {\n";
      for (j=0; (edge[i][j] != -1) && (j < MAX_FANOUT); j++);
      if ((j== 1) && (strcmp(edgeLabel[i][0].c_str(), "Submit") == 0)) {
	sprintf(buf, "      llSetTimerEvent(0); state %s;\n",
		nodeName[edge[i][0]].c_str());
	outfile << buf;
      } else {
	for (j=0; (edge[i][j] != -1) && (j < MAX_FANOUT); j++) {
	  sprintf(buf, "      if (msg == \"%s\") { llSetTimerEvent(0); state %s;}\n", 
		  edgeLabel[i][j].c_str(), nodeName[edge[i][j]].c_str());
	  outfile << buf;       	    
	}
      }
      outfile << "    } else {process_state_control_msg(c, n, ID, msg);}\n}\n}\n\n";
    }
  }
}

int main(int argc, char *argv[])
{
  if (argc != 3) {
    cout << "Usage: ./a.out inputgraphfile outputlslfile\n";
    exit(0);
  }
  readGraph(argv[1]);
  outfile.open(argv[2]);

  // printGraph();
  // this sequence generates a working lsl script
  gen_header();
  gen_fixed_variables();
  gen_msg_button();
  gen_utility_routine();
  gen_state_control_routine();
  gen_state();  
}
